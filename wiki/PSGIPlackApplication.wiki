#summary Considering a raw PSGI/Plack application
#labels PSGI,Plack,Perl

= Goals =
 
  * Freedom from frameworks, their design decisions and their future directions 
  * Lighter than Catalyst
  * Lighter than any current framework since has only the features I need
  * All best features from Catalyst, Dancer and Mojolicious (not to forget Mason, Mason2, HTTP::Engine, CGI::Application etc)
  * None of the drawbacks of the current frameworks :-D 
  * Possible portability to Perl6, Ruby although unlikely

= General =

  * Perl OO OK
  * Moose not needed not used
  * Stash based (passing data in stash seems to be the only viable solution)
  * Setups as separate plain text (encoded) cookies
  * Page caching based on URI & cookies
  * Model caching based on called model name & arguments
  * SQL result set caching based on SQL & arguments

= Dispatching =

Basic dispatching based on URL and then pass to correct Brick. Each Brick refine the dispatching from there so they have more rules. For my purposes URI scheme /lang/brick appears sufficient. System level dispatching can then be done based on brick.

= System object $sys  =

There is a need for a system object $sys like $c in Catalyst. That should be passed between the calls. It should be PSGI/Plack independent (prepare for future changes).

What to provide via $sys and what to provide via OO inheritance is a matter of serious consideration. It appears that $sys is better way to provide functionality than OO.

= Brick =
                                                       
Methods:
  * run: collect data from model and do the logic

== run ==

Run receives $self, $sys, $data (=stash). Typically it retrieves data from Model. Run collects the data to $data and calls renderer.

Run can also report status like 404 if there is no data found from the Model. 

== render ==

Xslate is very fast and doesn't allow Perl embedded which forces clean render separation from Brick.